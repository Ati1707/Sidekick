@using Sidekick.Apis.PoeNinja
@using Sidekick.Apis.PoeNinja.Models
@using Sidekick.Common.Browser
@using Sidekick.Common.Game.Items
@using Sidekick.Common.Game.Items.AdditionalInformation;
@using Sidekick.Modules.Trade.Localization

@if (Loading)
{
    <AppLoading/>
}
else if (Price != null)
{
    <div class="flex flex-nowrap items-center pt-2">
        <div class="text-right w-1/2 pr-2">
            <Heading3>@Resources["Poe.Ninja"]</Heading3>
            <TooltipTopRight>
                <ChildContent>
                    <TextCaption>@Price.LastUpdated.ToString("g")</TextCaption>
                </ChildContent>
                <TooltipContent>
                    @Resources["Last Updated"]
                </TooltipContent>
            </TooltipTopRight>
            <ButtonLink OnClick="OpenWebsite">
                <TextCaption>@Resources["Open Website"]</TextCaption>
            </ButtonLink>
        </div>
        <div class="text-left w-1/2 pl-2">
            <div class="flex">
                <PriceDisplay Value="Price.Price"/>
            </div>

            @if (Price.Links >= 5)
            {
                <TextCaption>@Price.Links @Resources["Links"]</TextCaption>
            }
        </div>
    </div>

    <ItemSeparator Rarity="PriceCheckService.Item?.Metadata.Rarity ?? Rarity.Unknown"/>
}

@inject IStringLocalizer<TradeResources> Resources
@inject IPoeNinjaClient Client
@inject IBrowserProvider BrowserProvider
@inject PriceCheckService PriceCheckService

@code {

    private bool Loading { get; set; }

    private NinjaPrice? Price { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();

        Loading = true;
        StateHasChanged();

        if (PriceCheckService.Item?.AdditionalInformation is ClusterJewelInformation clusterJewelInformation)
        {
            Price = await Client.GetClusterPrice(clusterJewelInformation.GrantText, clusterJewelInformation.SmallPassiveCount, PriceCheckService.Item.Properties.ItemLevel);
        }
        else
        {
            Price = await Client.GetPriceInfo(
                PriceCheckService.Item?.Invariant?.Name,
                PriceCheckService.Item?.Invariant?.Type,
                PriceCheckService.Item?.Metadata.Category ?? Category.Unknown,
                gemLevel: PriceCheckService.Item?.Properties.GemLevel,
                mapTier: PriceCheckService.Item?.Properties.MapTier,
                numberOfLinks: PriceCheckService.Item?.GetMaximumNumberOfLinks());
        }
        /*
                ChartOptions = new ChartOptions()
                {
                    DisableLegend = true,
                    XAxisLines = false,
                    YAxisLines = false,
                    ChartPalette = new string[] { "#ffffff" },
                };
                if (Price?.SparkLine?.Data.All(x => x.HasValue) == true)
                {
                    // Normalize values above 0 since the chart doesn't show negative values in the viewbox.
                    var sparkLineData = Price
                                        .SparkLine.Data.Select(x => x ?? 0)
                                        .ToArray();
                    var min = Math.Abs(sparkLineData.Min());
                    var chartData = sparkLineData
                                    .Select(x => x + min)
                                    .ToArray();

                    if (chartData.Any(x => x != 0))
                    {
                        Series =
                        [
                            new ChartSeries() { Data = chartData },
                        ];
                    }
                }

        */

        Loading = false;
        StateHasChanged();
    }

    private async Task OpenWebsite()
    {
        if (Price == null)
        {
            return;
        }

        var uri = await Client.GetDetailsUri(Price);
        BrowserProvider.OpenUri(uri);
    }

}
