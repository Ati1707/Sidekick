@if (XAxisLabels != null && Series.Count() >= 2)
{
    <MudChart ChartType="ChartType.Line" ChartSeries="@Series" XAxisLabels="@XAxisLabels" Width="100%" Height="@WealthView.ChartHeight">
    </MudChart>
}
else
{
    <MudAlert Dense="true" Variant="Variant.Outlined" Severity="Severity.Info">The tracker needs to run for 30 minutes to start generating this graph.</MudAlert>
}

@inject DbContextOptions<WealthDbContext> DbContextOptions
@inject ISettings Settings
@inject WealthParser WealthParser
@implements IDisposable
@code {
    [CascadingParameter]
    public WealthView View { get; set; } = null!;

    private List<ChartSeries> Series { get; set; } = new();
    private string[]? XAxisLabels { get; set; }

    protected override async Task OnInitializedAsync()
    {
        WealthParser.OnSnapshotTaken += Update;
        View.OnSelectedStashIdsChanged += Update;
        await LoadData();
        await base.OnInitializedAsync();
    }

    public void Update()
    {
        _ = InvokeAsync(async () =>
        {
            await LoadData();
            StateHasChanged();
        });
    }

    private async Task LoadData()
    {
        using var database = new WealthDbContext(DbContextOptions);
        var stashes = await database.Stashes
            .Where(x => View.SelectedStashIds.Contains(x.Id))
            .ToListAsync();
        var stashIds = stashes.Select(x => x.Id).ToList();

        var stashSnapshots = await database.StashSnapshots
            .Where(x => stashIds.Contains(x.StashId))
            .OrderByDescending(x => x.Total)
            .ToListAsync();

        var fullSnapshots = await database.FullSnapshots
            .Where(x => x.League == Settings.LeagueId)
            .ToListAsync();

        var dataPoints = stashSnapshots
            .GroupBy(x => $"{x.StashId}-{x.Date.Year}-{x.Date.Month.ToString("00")}-{x.Date.Day.ToString("00")} {x.Date.Hour.ToString("00")}:{((int)(x.Date.Minute / 30) == 0 ? "00" : "30")}")
            .Select(x => new DataPoint()
                {
                    DateString = x.Key.Substring(x.Key.IndexOf('-') + 1),
                    Name = stashes.First(y => x.First().StashId == y.Id).Name,
                    Value = x.OrderByDescending(y => y.Total).First().Total,
                })
            .ToList();

        dataPoints.AddRange(fullSnapshots
            .GroupBy(x => $"{x.Date.Year}-{x.Date.Month.ToString("00")}-{x.Date.Day.ToString("00")} {x.Date.Hour.ToString("00")}:{((int)(x.Date.Minute / 30) == 0 ? "00" : "30")}")
            .Select(x => new DataPoint()
                {
                    DateString = x.Key,
                    Name = "Total",
                    Value = x.OrderByDescending(y => y.Total).First().Total,
                })
            .ToList());

        var labels = dataPoints
            .Select(x => x.DateString)
            .Distinct()
            .Order()
            .ToArray();

        XAxisLabels = labels
            .Select(x => x.Substring(x.IndexOf('-') + 1))
            .ToArray();

        Series.Clear();
        foreach (var serie in dataPoints.GroupBy(x => x.Name))
        {
            var nullableData = labels.Select(label => serie.FirstOrDefault(x => x.DateString == label)?.Value ?? null).ToArray();
            var data = nullableData
                .Select((x, index) =>
                {
                    if (x == null && index > 0)
                    {
                        return nullableData[index - 1] ?? 0;
                    }

                    return x ?? 0;
                })
                .ToArray();

            Series.Add(new ChartSeries()
                {
                    Name = serie.First().Name,
                    Data = data,
                });
        }
    }

    public void Dispose()
    {
        WealthParser.OnSnapshotTaken -= Update;
        View.OnSelectedStashIdsChanged -= Update;
    }

    private class DataPoint
    {
        public required string DateString { get; init; }

        public double Value { get; init; }

        public required string Name { get; init; }
    }
}
